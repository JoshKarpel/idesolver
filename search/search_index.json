{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IDESolver","text":"<p>IDESolver is a package that provides an interface for solving real- or complex-valued integro-differential equations (IDEs) of the form</p> \\[ \\begin{aligned}     \\frac{dy}{dx} &amp; = c(y, x) + d(x) \\int_{\\alpha(x)}^{\\beta(x)} k(x, s) \\, f( y(s) ) \\, ds, \\\\     &amp; x \\in [a, b], \\quad y(a) = y_0. \\end{aligned} \\] <p>Integro-differential equations appear in many contexts, particularly when trying to describe a system whose future behavior depends on its own history and not just its present state. The IDESolver is an iterative solver, which means it generates successive approximations to the exact solution, using each approximation to generate the next (hopefully better) one. The algorithm is based on a scheme devised by Gelmi and Jorquera.</p> <p>If you use IDESolver in your work, please consider citing it .</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#idesolver.IDESolver","title":"<code>idesolver.IDESolver(x, y_0, c=None, d=None, k=None, f=None, lower_bound=None, upper_bound=None, global_error_tolerance=1e-06, max_iterations=None, ode_method='RK45', ode_atol=1e-08, ode_rtol=1e-08, int_atol=1e-08, int_rtol=1e-08, interpolation_kind='cubic', smoothing_factor=0.5, store_intermediate_y=False, global_error_function=global_error)</code>","text":"<p>A class that handles solving an integro-differential equation of the form</p> \\[ \\begin{aligned}     \\frac{dy}{dx} &amp; = c(y, x) + d(x) \\int_{\\alpha(x)}^{\\beta(x)} k(x, s) \\, f( y(s) ) \\, ds, \\\\     &amp; x \\in [a, b], \\quad y(a) = y_0. \\end{aligned} \\] ATTRIBUTE DESCRIPTION <code>x</code> <p>The positions where the solution is calculated (i.e., where \\(y\\) is evaluated).</p> <p> </p> <code>y</code> <p>The solution \\(y(x)\\). <code>None</code> until <code>IDESolver.solve</code> is finished.</p> <p> </p> <code>global_error</code> <p>The final global error estimate. <code>None</code> until <code>IDESolver.solve</code> is finished.</p> <p> </p> <code>iteration</code> <p>The current iteration. <code>None</code> until <code>IDESolver.solve</code> starts.</p> <p> </p> <code>y_intermediate</code> <p>The intermediate solutions. Only exists if <code>store_intermediate_y</code> is <code>True</code>.</p> <p> </p> PARAMETER DESCRIPTION <code>x</code> <p>The array of \\(x\\) values to find the solution \\(y(x)\\) at. Generally something like <code>numpy.linspace(a, b, num_pts)</code>.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>y_0</code> <p>The initial condition, \\(y_0 = y(a)\\) (can be multidimensional).</p> <p> TYPE: <code>Union[float, np.float64, complex, np.complex128, np.ndarray, list]</code> </p> <code>c</code> <p>The function \\(c(y, x)\\). Defaults to \\(c(y, x) = 0\\).</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>d</code> <p>The function \\(d(x)\\). Defaults to \\(d(x) = 1\\).</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>k</code> <p>The kernel function \\(k(x, s)\\). Defaults to \\(k(x, s) = 1\\).</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>f</code> <p>The function \\(F(y)\\). Defaults to \\(f(y) = 0\\).</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>lower_bound</code> <p>The lower bound function \\(\\alpha(x)\\). Defaults to the first element of <code>x</code>.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>upper_bound</code> <p>The upper bound function \\(\\beta(x)\\). Defaults to the last element of <code>x</code>.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>global_error_tolerance</code> <p>The algorithm will continue until the global errors goes below this or uses more than <code>max_iterations</code> iterations. If <code>None</code>, the algorithm continues until hitting <code>max_iterations</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-06</code> </p> <code>max_iterations</code> <p>The maximum number of iterations to use. If <code>None</code>, iteration will not stop unless the <code>global_error_tolerance</code> is satisfied. Defaults to <code>None</code>.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>ode_method</code> <p>The ODE solution method to use. As the <code>method</code> option of :func:<code>scipy.integrate.solve_ivp</code>. Defaults to <code>'RK45'</code>, which is good for non-stiff systems.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'RK45'</code> </p> <code>ode_atol</code> <p>The absolute tolerance for the ODE solver. As the <code>atol</code> argument of :func:<code>scipy.integrate.solve_ivp</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>ode_rtol</code> <p>The relative tolerance for the ODE solver. As the <code>rtol</code> argument of :func:<code>scipy.integrate.solve_ivp</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>int_atol</code> <p>The absolute tolerance for the integration routine. As the <code>epsabs</code> argument of :func:<code>scipy.integrate.quad</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>int_rtol</code> <p>The relative tolerance for the integration routine. As the <code>epsrel</code> argument of :func:<code>scipy.integrate.quad</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>interpolation_kind</code> <p>The type of interpolation to use. As the <code>kind</code> argument of :class:<code>scipy.interpolate.interp1d</code>. Defaults to <code>'cubic'</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cubic'</code> </p> <code>smoothing_factor</code> <p>The smoothing factor used to combine the current guess with the new guess at each iteration. Defaults to <code>0.5</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>store_intermediate_y</code> <p>If <code>True</code>, the intermediate guesses for \\(y(x)\\) at each iteration will be stored in the attribute <code>y_intermediate</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>global_error_function</code> <p>The function to use to calculate the global error. Defaults to :func:<code>global_error</code>.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>global_error</code> </p>"},{"location":"api/#idesolver.idesolver.IDESolver.solve","title":"<code>solve(callback=None)</code>","text":"<p>Compute the solution to the IDE.</p> <p>Will emit a warning message if the global error increases on an iteration. This does not necessarily mean that the algorithm is not converging, but may indicate that it's having problems.</p> <p>Will emit a warning message if the maximum number of iterations is used without reaching the global error tolerance.</p> PARAMETER DESCRIPTION <code>callback</code> <p>A function to call after each iteration. The function is passed the <code>IDESolver</code> instance, the current \\(y\\) guess, and the current global error.</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>np.ndarray</code> <p>The solution to the IDE (i.e., \\(y(x)\\)).</p>"},{"location":"api/#idesolver.global_error","title":"<code>idesolver.global_error(y1, y2)</code>","text":"<p>The default global error function.</p> <p>The estimate is the square root of the sum of squared differences between <code>y1</code> and <code>y2</code>.</p> PARAMETER DESCRIPTION <code>y1</code> <p>A guess of the solution.</p> <p> TYPE: <code>np.ndarray</code> </p> <code>y2</code> <p>Another guess of the solution.</p> <p> TYPE: <code>np.ndarray</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The global error estimate between <code>y1</code> and <code>y2</code>.</p>"},{"location":"api/#idesolver.complex_quad","title":"<code>idesolver.complex_quad(integrand, lower_bound, upper_bound, **kwargs)</code>","text":"<p>A thin wrapper over <code>scipy.integrate.quad</code> that handles splitting the real and complex parts of the integral and recombining them. Keyword arguments are passed to both of the internal <code>scipy.integrate.quad</code> calls.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#110","title":"<code>1.1.0</code>","text":"<p>Released <code>2022-11-19</code></p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>#35 Add support for multidimensional IDEs, by @nbrucy.</li> </ul>"},{"location":"changelog/#105","title":"<code>1.0.5</code>","text":"<p>Released <code>2020-09-15</code></p>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Relaxed dependency version restrictions in advance of changes to <code>pip</code>.   There shouldn't be any impact on users.</li> </ul>"},{"location":"changelog/#104","title":"<code>1.0.4</code>","text":"<p>Released <code>2019-10-24</code></p>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Revision of packaging and CI flow. There shouldn't be any impact on users.</li> </ul>"},{"location":"changelog/#103","title":"<code>1.0.3</code>","text":"<p>Released <code>2022-02-27</code></p>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Revision of package structure and CI flow. There shouldn't be any impact on users.</li> </ul>"},{"location":"changelog/#102","title":"<code>1.0.2</code>","text":"<p>Released <code>2018-01-30</code></p>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>IDESolver now explicitly requires Python 3.6+. Dependencies on <code>numpy</code> and <code>scipy</code> are given as lower bounds.</li> </ul>"},{"location":"changelog/#101","title":"<code>1.0.1</code>","text":"<p>Released <code>2018-01-14</code></p>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Changed the name of <code>IDESolver.F</code> to <code>IDESolver.f</code>, as intended.</li> <li>The default global error function is now injected instead of hard-coded.</li> </ul>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>IDESolver is open to contributions!</p> <ul> <li>Report bugs and request features</li> <li>General discussion</li> <li>Pull requests</li> </ul>"},{"location":"contributing/#development-environment","title":"Development Environment","text":"<p>IDESolver uses:</p> <ul> <li><code>poetry</code> to manage development dependencies.</li> <li><code>pre-commit</code> to run various linters and formatters.</li> <li><code>pytest</code> for testing and <code>mypy</code> for static type-checking.</li> <li><code>mkdocs</code> with the Material theme for documentation.</li> </ul>"},{"location":"contributing/#initial-setup","title":"Initial Setup","text":"<p>To set up a local development environment after cloning the repository:</p> <ol> <li>Install <code>poetry</code>.</li> <li>Run <code>poetry shell</code> to create a virtual environment for <code>idesolver</code> and spawn a new shell session with that virtual environment activated.    In the future you'll run <code>poetry shell</code> again to activate the virtual environment.</li> <li>Run <code>poetry install</code> to install IDESolver's dependencies.</li> <li>Run <code>pre-commit install</code> to configure <code>pre-commit</code>'s integration with <code>git</code>.    Do not commit without <code>pre-commit</code> installed!</li> </ol>"},{"location":"contributing/#running-tests-and-type-checking","title":"Running Tests and Type-Checking","text":"<p>Run <code>pytest</code> to run tests.</p> <p>Run <code>mypy</code> to check types.</p>"},{"location":"contributing/#building-the-docs-locally","title":"Building the Docs Locally","text":"<p>To build the docs and start a local web server to view the results of your edits with live reloading, run <pre><code>mkdocs serve\n</code></pre> from the repository root.</p>"},{"location":"manual/","title":"Manual","text":"<p>IDESolver implements an iterative algorithm from this paper for solving general IDEs. The algorithm requires an ODE integrator and a quadrature integrator internally. IDESolver uses <code>scipy.integrate.solve_ivp</code> as the ODE integrator. The quadrature integrator is either <code>scipy.integrate.quad</code> or <code>idesolver.complex_quad</code>, a thin wrapper over <code>scipy.integrate.quad</code> which handles splitting the real and imaginary parts of the integral.</p>"},{"location":"manual/#the-algorithm","title":"The Algorithm","text":"<p>We want to find an approximate solution to</p> \\[ \\begin{aligned}     \\frac{dy}{dx} &amp; = c(y, x) + d(x) \\int_{\\alpha(x)}^{\\beta(x)} k(x, s) \\, F( y(s) ) \\, ds, \\\\     &amp; x \\in [a, b], \\quad y(a) = y_0. \\end{aligned} \\] <p>The algorithm begins by creating an initial guess for \\(y\\) by using an ODE solver on</p> \\[     \\frac{dy}{dx} = c(y, x) \\] <p>Since there's no integral on the right-hand-side, standard ODE solvers can handle it easily. Call this guess \\(y^{(0)}\\). We can then produce a better guess by seeing what we would get with the original IDE, but replacing \\(y<code>on the right-hand-side by :math:</code>y^{(0)}\\):</p> \\[     \\frac{dy^{(1/2)}}{dx} = c(y^{(0)}, x) + d(x) \\int_{\\alpha(x)}^{\\beta(x)} k(x, s) \\, F( y^{(0)}(s) ) \\, ds \\] <p>Again, this is just an ODE, because \\(y^{(1/2)}\\) does not appear on the right. At this point in the algorithm we check the global error between \\(y^{(0)}\\) and \\(y^{(1/2)}\\). If it's smaller than the tolerance, we stop iterating and take \\(y^{(1/2)}\\) to be the solution. If it's larger than the tolerance, the iteration continues. To be conservative and to make sure we don't over-correct, we'll combine \\(y^{(1/2)}\\) with \\(y^{(0)}\\).</p> \\[     y^{(1)} = \\alpha \\, y^{(0)} + (1 - \\alpha) \\, y^{(1/2)} \\] <p>The process then repeats: solve the IDE-turned-ODE with \\(y^{(1)}\\) on the right-hand-side, see how different it is, maybe make a new guess, etc.</p>"},{"location":"manual/#stopping-conditions","title":"Stopping Conditions","text":"<p>IDESolver can operate in three modes: either a nonzero global error tolerance should be given, or a maximum number of iterations should be given, or both should be given.</p> <ul> <li>Nonzero global error tolerance is the standard mode, as described above.</li> <li>If a maximum number of iterations is given with zero global error tolerance, the algorithm will iterate that many times and then stop.</li> <li>If both are given, the algorithm terminates if either condition is met.</li> </ul>"},{"location":"manual/#global-error-estimate","title":"Global Error Estimate","text":"<p>The default global error estimate $G` between two possible solutions \\(y_1\\) and \\(y_2\\) is</p> \\[     G(y_1, y_2) = \\sqrt{ \\sum_{x_i} \\left| y_1(x_i) - y_2(x_i) \\right| } \\] <p>A different global error estimator can be passed in the constructor as the argument <code>global_error_function</code>.</p>"},{"location":"parallelization/","title":"Parallelization","text":""},{"location":"parallelization/#can-i-pickle-an-idesolver-instance","title":"Can I pickle an <code>IDESolver</code> instance?","text":"<p>Yes, with one caveat. You'll need to define the callables somewhere that Python can find them in the global namespace (i.e., top-level functions in a module, methods in a top-level class, etc.).</p>"},{"location":"parallelization/#can-i-parallelize-idesolver-over-multiple-cores","title":"Can I parallelize IDESolver over multiple cores?","text":"<p>Not directly: the iterative algorithm is serial by nature.</p> <p>However, if you have lots of IDEs to solve, you can farm them out to individual cores using Python's <code>multiprocessing</code> module (multithreading won't provide any advantage). Here's an example of using a <code>multiprocessing.Pool</code> to solve several IDEs in parallel:</p> <pre><code>import multiprocessing\nimport numpy as np\nfrom idesolver import IDESolver\ndef run(solver):\nsolver.solve()\nreturn solver\ndef c(x, y):\nreturn y - (0.5 * x) + (1 / (1 + x)) - np.log(1 + x)\ndef d(x):\nreturn 1 / (np.log(2)) ** 2\ndef k(x, s):\nreturn x / (1 + s)\ndef lower_bound(x):\nreturn 0\ndef upper_bound(x):\nreturn 1\ndef f(y):\nreturn y\nif __name__ == \"__main__\":\nides = [\nIDESolver(\nx=np.linspace(0, 1, 100),\ny_0=0,\nc=c,\nd=d,\nk=k,\nlower_bound=lower_bound,\nupper_bound=upper_bound,\nf=f,\n)\nfor y_0 in np.linspace(0, 1, 10)\n]\nwith multiprocessing.Pool(processes=2) as pool:\nresults = pool.map(run, ides)\nprint(results)\n</code></pre> <p>Note that the callables all need to defined before the if-name-main so that they can be pickled.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Suppose we want to solve the integro-differential equation (IDE)</p> \\[ \\begin{aligned}     \\frac{dy}{dx} &amp; = y(x) - \\frac{x}{2} + \\frac{1}{1 + x} - \\ln(1 + x) + \\frac{1}{\\left(\\ln(2)\\right)^2} \\int_0^1 \\frac{x}{1 + s} \\, y(s) \\, ds, \\\\     &amp; x \\in [0, 1], \\quad y(0) = 0. \\end{aligned} \\] <p>The analytic solution to this IDE is \\(y(x) = \\ln(1 + x)\\). We'll find a numerical solution using IDESolver and compare it to the analytic solution.</p> <p>The very first thing we need to do is install IDESolver. If you're using <code>pip</code>, that will be something like running <code>python -m pip install idesolver</code> in your terminal, ideally with a virtual environment activated.</p> <p>Now we can create an instance of <code>IDESolver</code>, passing it information about the IDE that we want to solve. The format is</p> \\[ \\begin{aligned}    \\frac{dy}{dx} &amp; = c(y, x) + d(x) \\int_{\\alpha(x)}^{\\beta(x)} k(x, s) \\, F( y(s) ) \\, ds, \\\\    &amp; x \\in [a, b], \\quad y(a) = y_0. \\end{aligned} \\] <p>so we have</p> \\[ \\begin{aligned}     a &amp;= 0 \\\\     b &amp;= 1 \\\\     y(a) &amp;= 0 \\\\ \\\\     c(x, y) &amp;= y(x) - \\frac{x}{2} + \\frac{1}{1 + x} - \\ln(1 + x) \\\\     d(x) &amp;= \\frac{1}{\\left(\\ln(2)\\right)^2} \\\\     k(x, s) &amp;= \\frac{x}{1 + s} \\\\     f(s) &amp;= y(s) \\\\ \\\\     \\alpha(x) &amp;= 0 \\\\     \\beta(x) &amp;= 1. \\end{aligned} \\] <p>In code, that looks like (using <code>lambda</code> functions for compactness):</p> <pre><code>import numpy as np\nfrom idesolver import IDESolver\nsolver = IDESolver(\nx=np.linspace(0, 1, 100),\ny_0=0,\nc=lambda x, y: y - (0.5 * x) + (1 / (1 + x)) - np.log(1 + x),\nd=lambda x: 1 / (np.log(2)) ** 2,\nk=lambda x, s: x / (1 + s),\nf=lambda y: y,\nlower_bound=lambda x: 0,\nupper_bound=lambda x: 1,\n)\n</code></pre> <p>To run the solver, we call the <code>solve()</code> method:</p> <pre><code>solver.solve()\nsolver.x  # whatever we passed in for x\nsolver.y  # the solution y(x)\n</code></pre> <p>The default global error tolerance is \\(10^{-6}\\), with no maximum number of iterations. For this IDE the algorithm converges in 40 iterations, resulting in a solution that closely approximates the analytic solution, as seen below.</p> <pre><code>import matplotlib.pyplot as plt\nfig = plt.figure(dpi=600)\nax = fig.add_subplot(111)\nexact = np.log(1 + solver.x)\nax.plot(solver.x, solver.y, label=\"IDESolver Solution\", linestyle=\"-\", linewidth=3)\nax.plot(solver.x, exact, label=\"Analytic Solution\", linestyle=\":\", linewidth=3)\nax.legend(loc=\"best\")\nax.grid(True)\nax.set_title(f\"Solution for Global Error Tolerance = {solver.global_error_tolerance}\")\nax.set_xlabel(r\"$x$\")\nax.set_ylabel(r\"$y(x)$\")\nplt.show()\n</code></pre> <p></p> <pre><code>fig = plt.figure(dpi=600)\nax = fig.add_subplot(111)\nerror = np.abs(solver.y - exact)\nax.plot(solver.x, error, linewidth=3)\nax.set_yscale(\"log\")\nax.grid(True)\nax.set_title(\nf\"Local Error for Global Error Tolerance = {solver.global_error_tolerance}\"\n)\nax.set_xlabel(r\"$x$\")\nax.set_ylabel(r\"$\\left| y_{\\mathrm{idesolver}}(x) - y_{\\mathrm{analytic}}(x) \\right|$\")\nplt.show()\n</code></pre> <p></p>"}]}